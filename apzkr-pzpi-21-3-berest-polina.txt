Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА

з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для автоматизації логістики інтернет-шопінгу

Студент гр. ПЗПІ-21-3 	__________________ Берест П. В.
    (підпис)

Керівник роботи 		__________________ доц. Лещинська І.О.
    (підпис)
                           Роботу захищено «__»_________2024 р.
                           з оцінкою _________________________

Комісія: 				__________________ доц. Лещинська І.О.
    (підпис)
    __________________ доц. Лещинський В.О.
    (підпис)
    __________________ ст.викл. Сокорчук І.П.
    (підпис)
    
Харків
2024 р.
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук                           Кафедра програмної інженерії     
Спеціальність 121 – Інженерія програмного забезпечення                                       
Курс                   3                   Семестр                                  6                                       
Навчальна дисципліна Архітектура програмного забезпечення                              

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ

                                             Берест Поліні Володимирівні                                           
1. Тема роботи: «Програмна система для автоматизації логістики інтернет-шопінгу»
2. Термін узгодження завдання курсової роботи «   19   »    лютого     2024 р.
3. Термін здачі студентом закінченої роботи «   15   »    червня     2024 р.
4. Вихідні дані до проекту (роботи): В програмній системі передбачити: реєстрацію та авторизацію менеджерів магазину, покупців, адміністраторів та системних адміністраторів системи, додавання та оновлення інформації про товари та постачальників, додавання, редагування та розгляд заявок на встановлення та деінсталяцію розумних точок видачі, підключення до системи та налаштування точок видачі різної конфігурації, збір та виведення статистики для адміністратора системи щодо використання організаціями-підписниками точок видачі, обчислення помісячних внесків у відповідності до активності організацій, збір та виведення статистики для організацій стосовно замовлень у використовуваних точках видачі, управління користувачами системи, управління бекапами, автоматичну генерацію та адміністративний розгляд заявок на технічну підтримку точок видачі, створення клієнтом замовлення та відстеження його стану виконання, зміну стану замовлення та комірки точки видачі при створенні, доставці та видачі замовлення, ведення обліку замовлень, виведення клієнтам персоналізованих пропозицій щодо замовлень. Використовувати ОС Windows 10, СКБД Microsoft SQL Server 2019, середовища розробки Microsoft Visual Studio 2022, Android Studio, редактор коду Visual Studio Code, мови програмування С#, TypeScript, Java, фреймворк Angular 17                                                                                          
5. Зміст пояснювальної записки (перелік питань, що належить розробити)
вступ, аналіз предметної області, постановка задачі, проектування програмного проекту, структура бази даних, кодування програмного проекту, опис розробленої програмної системи, висновки, перелік посилань, додатки                                                                                                                          
6. Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень)
схема моделі баз даних, діаграма прецедентів, діаграма розгортання, діаграма компонентів, діаграма діяльності, інтерфейс додатку                                           


КАЛЕНДАРНИЙ ПЛАН


№Назва етапів курсової роботиТермін виконання
етапів роботиПримітка1Функціональна специфікація
програмного проекту26.02.2024виконано2Проектування програмного
проекту04.03.2024виконано3Кодування програмного проекту20.05.2024виконано4Оформлення пояснювальної
записки05.06.2024виконано5Захист курсової роботи10.06.2024виконано

Дата видачі завдання «   19   »       лютого       2024 р.

Керівник 					______________ доц. Лещинська І.О.
(підпис)

Завдання прийняла до виконання
ст.гр. ПЗПІІ-21-3					      _____________ Берест П. В.
 (підпис)


     РЕФЕРАТ
     
     Пояснювальна записка до курсової роботи: 86 с., 16 рис., 11 додатків, 8 джерел посилання.
     ІНТЕРНЕТ-ЗАМОВЛЕННЯ, ІНТЕРНЕТ-МАГАЗИН, МАРКЕТПЛЕЙС, ОПТИМІЗАЦІЯ ЛОГІСТИКИ, ПОСТАМАТ, ТОЧКА ВИДАЧІ.
     
     Об’єктом дослідження є сфера продажів – популярне явище замовлення товарів в Інтернеті. Відкритим питанням наразі є організація процесу: зручний майданчик продажів та покупок, оптимізація логістичних процесів для отримання клієнтами замовлень у зручному місці в зручний час, надання можливості замовити товари, що потребують особливих умов зберігання.
     Метою роботи є створення платформи, де компанії розміщуватимуть товар для продажу, а клієнти – здійснюватимуть покупки. Забрати замовлення можна в зручний час в обраній автоматизованій точці видачі, установленій на замовлення компанії в одному з магазинів або в громадському місці. Точки конфігуруються за вимогами компанії-замовника: можуть містити різну кількість та тип комірок (за підтримкою температурного режиму). Постамати збирають статистику використання, відстежують свою справність та автоматично генерують запити на технічну підтримку. Планується розробити програмний інтерфейс для можливої інтеграції з сервісом доставки роботами.
     Методи розробки включають використання платформи .NET 7, ASP.NET Core, REST API та Odata, серверу бази даних MS SQL Server 2019. Веб-клієнт базується на Angular Framework 17 із використанням мови програмування TypeScript, мобільний – на Java Android. IoT будується на апаратній базі контролера Raspberry Pi, який підтримує виконання коду на C# та доступ до Інтернету. На пристрої має бути встановлено .NET Core, планується розробка міні-сервера, який підтримує зв’язок з системою за допомогою HTTP-запитів.
     У результаті роботи здійснено програмну реалізацію системи для швидких онлайн-замовлень з отриманням у зручних за розташуванням точках видачі та в зручний для клієнта час, прототип розумної точки видачі. Програмна система складається з веб-додатку, сервера, мобільного додатку та смарт-пристрою.
     ЗМІСТ

     ВСТУП	8
     1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ	10
     1.1 Загальний огляд предметної області	10
     1.2 Аналіз аналогів системи	11
     2 ПОСТАНОВКА ЗАВДАННЯ	14
     2.1 Затвердження бачення програмної системи	14
     2.2 Користувачі системи та потреби цільового ринку	15
     2.3 Припущення та залежності	16
     2.4 Основний функціонал та сценарії використання системи	16
     2.5 Ризики програмної системи	18
     2.6 Обмеження та винятки	18
     2.7 Вимоги до програмної системи та стек технологій	19
     3 АРХІТЕКТУРА Й ПРОЄКТУВАННЯ СИСТЕМИ	23
     3.1 UML-моделювання	23
     3.2 Проєктування бази даних	23
     3.3 Загальна архітектура програмної системи	24
     3.4 Архітектура серверної частини	25
     3.5 Архітектура веб-клієнта	26
     3.6 Архітектура ІоТ	28
     3.7 Архітектура мобільного клієнта	29
     4 ОПИС ПРОГРАМНИХ РІШЕНЬ	32
     4.1 Програмні рішення серверного застосунку	32
        4.1.1 Робота з базою даних	32
        4.1.2 Автентифікація	32
        4.1.3 Специфікація REST API	34
        4.1.4 Валідація на сервері	34
        4.1.5 Використання механізму Dependency Injection	35
        4.1.6 Забезпечення безпеки даних	35
     4.2 Програмні рішення веб-клієнта	36
        4.2.1 Формування запитів	36
        4.2.2 Валідація користувацького введення	37
        4.2.3 Локалізація	39
        4.2.4 Користувацький інтерфейс	40
     4.3 Програмні рішення ІоТ-застосунку	43
        4.3.1 Формування запитів	43
        4.3.2 Локалізація	44
        4.3.3 Обчислення статистики	46
        4.2.4 Адміністрування пристрою	46
     4.4 Програмні рішення мобільного клієнта	46
        4.4.1 Формування запитів	46
        4.4.2 Автентифікація	47
        4.4.3 Локалізація	48
        4.4.4 Кристувацький інтерфейс	49
     ВИСНОВКИ	56
     ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ	57
     ДОДАТОК А – UML-діаграма прецедентів	58
     ДОДАТОК Б – UML-діаграма станів	59
     ДОДАТОК В – ER-діаграма	60
     ДОДАТОК Г – UML-діаграма розгортання серверного застосунку	61
     ДОДАТОК Д – ApplicationDbContext.cs	62
     ДОДАТОК Е – AppRoutingModule.ts	64
     ДОДАТОК Ж – AuthInterceptor.java	68
     ДОДАТОК И – AuthService.cs	71
     ДОДАТОК К – ODataControllerBase.cs	77
     ДОДАТОК Л – Специфікація REST API	80
     ДОДАТОК М – Результат перевірки на відсоток плагіату	86


     ВСТУП
     
     Наразі завдяки розвитку технологій та пришвидшення темпів житті все більш популярним стає явище замовлення товарів в Інтернеті. Відкритим питанням наразі залишається організація процесу: зручний майданчик продажів та покупок, оптимізація логістичних процесів для отримання клієнтами замовлень у зручному місці в зручний час, надання можливості замовити товари, що потребують особливих умов зберігання, та його автоматизація для скорочення ресурсів, необхідних для опрацювання та видачі замовлень.
     Метою виконання курсового проєкту є набуття навичок зі створення програмної системи з автоматизації логістики інтернет-замовлень, яку планується запропонувати малим та середнім бізнесам з метою вирішення проблем логістики та видачі замовлень в ніші здійснення замовлень онлайн. 
     Спроєктована система має бути платформою, на якій зареєстровані компанії можуть розміщувати свій товар для продажу, а їхні клієнти – здійснювати онлайн-покупки. При цьому забрати замовлення клієнт може не на пошті чи в магазині, а в обраному постаматі видачі, установленому на замовлення компанії в одному з її магазинів або у громадському місці: на першому поверсі ТЦ, на виході з метро, в офісі великої компанії. Постамати формуються та конфігуруються за вимогами компанії-замовника: можуть містити різну кількість та тип комірок видачі. Постамат збирає статистику свого використання, відстежує свою справність та автоматично генерує запити на технічну підтримку, які надходять адміністраторам системи. Також у системі передбачено можливість інтеграції з сервісом доставки замовлень роботом: розроблено інтерфейс для отримання роботом переліку замовлень, відповідних постаматів та ключів доступу, створено інтерфейс взаємодії з постаматом. 
     Зокрема мета виконання такого проєкту – здобути практичні навички з розробки складних програмних систем з багатьох частин (серверного застосунку, веб-клієнта, ІоТ та мобільного застосунку) з використанням основних принципів проєктування архітектури програмного забезпечення.
     Для досягнення мети виконано такі завдання: вивчення можливих варіантів архітектур програмного забезпечення, патернів проєктування [1], принципів «чистого» коду [2], аналіз предметної області, галузі застосування та впровадження програмного рішення; проєктування системи та бази даних; програмну реалізацію задуму з дотриманням принципів «чистого» коду [2, 3] та «чистої» архітектури.


     1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
     1.1 Загальний огляд предметної області
     
     Наразі в світі все більш розвиненою стає культура інтернет замовлень, оскільки користувач оцінив переваги вибору товарів у комфортних умовах та забирання «кошика» у зручний час: економія часу, можливість знайти потрібний, а не наявний у магазині товар [4]. 
     Така тенденція змушує бізнеси створювати власні розрізнені майданчики для продажів (сайти аптек, магазинів косметики, солодощів тощо) та вкладати кошти в просування й технічну підтримку. Для малих бізнесів створення власних технічних систем не є фінансово виправданим, а клієнтові зручніше робити покупки в популярних системах із широким асортиментом. Цю проблему наразі вирішують маркетплейси. 
     Серед замовлень на електронних майданчиках можна виділити два основних типи: з адресною доставкою (доставка поштою чи кур’єром) та інтернет-замовлення з метою забрати свої товари на касі магазину вже зібраними.
     Перший тип включає в себе передачу логістичних процесів поштовим сервісам. Це породжує проблему суттєвих додаткових витрати клієнта на оплату доставок (часто оплата доставки дорівнює вартості товару), зниження зацікавленості у покупці, пошуку клієнтом магазинів, де можливий самовивіз.
     Другий тип включає необхідність цілеспрямованого походу до точки видачі, врахування робочих годин, очікування в черзі.
     Предметна область охоплює сферу електронної комерції та логістики. Основною ідеєю En Route є створення екосистеми продажів, у якій клієнт зможе робити швидкі покупки «на ходу»: робити замовлення, які буде зібрано та покладено у комірку тимчасового зберігання, повз місце розташування якої клієнт проходитиме протягом дня. Постамати з комірками можна розташувати:
     – поруч із магазином, щоб клієнтові не потрібно було заходити всередину;
     – в офісному приміщенні (в комірки з контролем температурного режиму можна замовити їжу);
     – на зупинці громадського транспорту чи на виході з метро;
     – на першому поверсі ТРЦ (щоб зекономити час клієнта на підйом на потрібний поверх чи перечікування повітряної тривоги).
     Такий підхід до покупок та продажів змінює систему логістики та усуває зайву поштову ланку, до послуг якої вдаються через віддаленість або не зручні робочі години магазину. Зручність для клієнта пожвавлює продажі: такий підхід сприяє постійним дрібним замовленням, які за сумарною вартістю зможуть перевищити дохід від великих замовлень з доставкою. 
     До того ж, на меті при створення системи також стоїть забезпечити можливість інтеграції сервісу доставок за допомогою роботів: такий підхід також дозволить власникам бізнесів зекономити на оплаті часу співробітника магазину, який буде відповідальним за закладання до комірок сформованих замовлень.
     Система має збирати статистику щодо кожного з пунктів видачі. Менеджери магазинів на основі наданих системою даних зможуть зробити висновки щодо своїх найбільш популярних товарів або категорій товарів та адаптувати асортимент магазинів для отримання більшої вигоди, визначать точки для подальшого встановлення постаматів. 
     Система має ставити на меті використання переваг маркетплейсів та покращення логістичних процесів для малих бізнесів, зменшення витрат та збільшення контролю над логістикою. Систему розроблено для компаній, які бажають надавати клієнтам можливість отримати свої замовлення в зручних для них постаматах, та для їхніх клієнтів, які бажають здійснювати покупки зручно та швидко.
     
1.2 Аналіз аналогів системи

     На ринку вже існують способи організації електронних покупок та логістичних процесів для замовлень. Основними конкурентами розробленої системи наразі є маркетплейси (Rozetka, Prom), також конкурентними є постачальники послуг з оренди пристроїв за типом постаматів (MVK Mash). 
     Маркетплейси впроваджують ідею про надання малим та середнім бізнесам майданчику для здійснення інтернет-продажів.
     Конкурентною перевагою системи у порівнянні з підходом маркетплейсів є спосіб організації логістики: 
     – клієнт може забрати замовлення безкоштовно, не оплачуючи доставку поштою, без вагань робить маленькі замовлення, які не є вигідними за умови доставки поштою;
     – клієнт не має враховувати робочі години точки видачі, стояти в черзі до оператора, виділяти спеціальний час для отримання замовлення, заходити в приміщення (що є актуальним під час карантину чи повітряної тривоги); 
     – клієнт може обирати точку видачі, повз яку проходитиме протягом дня – і швидко забирати замовлення;
     – система підходить для продажу квітів, ліків, продуктів чи готових страв завдяки можливості температурного контролю та швидкості забирання замовлень.
     Сервіси, які займаються наданням комірок видачі та постаматів, вирішують питання зручності в логістиці, надають бізнесу статистику за використовуваними пристроями, контроль за видачею замовлень. Проте вони мають суттєві недоліки, які в системі En Route усунені. Для використання звичайного постамату необхідно розробити та підтримувати власну програмну систему для онлайн-замовлень, в яку буде інтегровано точку видачі. До проблем такого підходу також належать:
     – відсутність можливості сконфігурувати точку видачі з різнотипними комірками: з підтримкою температурного режиму та без;
     – необхідність здійснювати самостійний технічний огляд постаматів;
     – відсутність можливості відмовитися від замовлення;
     – відсутність можливості інтеграції з сервісом доставки товару з магазину до точки видачі за допомогою роботів.
     Розроблена інформаційна система En Route пропонує поєднати переваги роботи з маркетплейсами, зручні для бізнесів-підписників, та  вигоду для клієнтів від використання розумних постаматів для отримання замовлення. Використання системи пожвавить продажі для бізнесів-підписників за рахунок інноваційного та комфортного для клієнтів сервісу. 
     Менеджери магазинів-підписників отримають можливість замовити встановлення та самостійно сконфігурувати необхідну точку видачі, спираючись на власні потреби та аналізуючи надану статистику інших точок видачі, записаних на компанію. Менеджери та інші зареєстровані працівники компаній отримують повний контроль над своїм «профілем» у системі: можуть виставляти на продаж товари, змінювати асортимент, приймати електронні замовлення та контролювати логістичний процес, який включатиме доставку до точки видачі (працівником або роботом-доставником), можливе повернення товару, зібрану за замовленнями статистику. Пристрої видачі самостійно контролюють свій стан та автоматично формують повідомлення та запит на технічну підтримку в разі виявлення несправності. Клієнт отримує зручний застосунок, у якому може зробити замовлення в безлічі магазинах (орієнтуючись на необхідність товару або на розташування точки видачі «на шляху»), отримати персоналізовані рекомендації щодо наступних вигідних покупок, проконтролювати стан замовлення та забрати чи відмовитися від замовлення біля постамату.
     Продукт орієнтований на український, європейський та американський ринки, для клієнтів перелічених ринків справедливо твердження, що час – це гроші, у культурі продажів закладена та цінується турбота про покупця.
     Монетизація системи за планом має складатися зі щомісячної плати зареєстрованих бізнесів за доступ до платформи, яка залежатиме від кількості зареєстрованих на компанію постаматів та кількості отриманих в точках видачі замовлень, внесків за встановлення постаматів.


     2 ПОСТАНОВКА ЗАВДАННЯ
     2.1 Затвердження бачення програмної системи
     
     Інформаційна система En Route надаватиме послуги зі здійснення покупок в інтернеті із подальшим швидким отриманням замовлення у зручний час у зручній точці видачі. 
     Зробити замовлення та обрати зручний пункт видачі можна в мобільному застосунку користувача, зазначивши місце свого перебування. Пропозиції магазинів буде відфільтровано за територіальним принципом (чи має магазин пункт видачі поблизу), скористувавшись застосунком для відкриття комірки точки видачі, користувач у будь-який зручний час може отримати своє замовлення, яке було доставлено представником компанії-продавця та зберігалося в належних умовах (з дотриманням необхідного температурного режиму). Користувач також отримуватиме персоналізовані рекомендації щодо подальших покупок через застосунок, сформовані на основі категорій та цінового діапазону попередніх замовлень, розташування «улюблених» точок видачі.
     Менеджери компаній-підписниць зможуть керувати встановленими для їхніх магазинів точками видачі, подавати заявки на встановлення з указанням необхідної конфігурації та на деінсталяцію, отримувати статистику від системи для оптимізації мережі видачі замовлень та оптимізації асортименту відповідно до потреб користувача, вести облік товарів зі свого асортименту. Працівники магазинів зможуть отримувати онлайн-замовлення та сповіщати про доставку сформованого замовлення в точку видачі. Доставку замовлень у комірки можна також делегувати роботам-доставникам, оскільки авторизований як доставник від компанії девайс може отримати всю необхідну інформацію для роботи.
     Адміністратори отримають доступ до управління користувачами та їхніми можливостями в системі, статистику щодо використання компаніями системи та обчислену вартість підписки для кожної з компаній відповідно до її активності, зможуть управляти точками видачі та їхньою технічною підтримкою.
     2.2 Користувачі системи та потреби цільового ринку
     
     Система задовольняє  потреби: покупців, які роблять замовлення онлайн і мають потребу отримувати інтернет-замовлення (у тому числі ті, товари в яких потребують спеціального температурного режиму зберігання) швидко, у зручний час та не плануючи для цього окрему прогулянку;  малих та середніх бізнесів, які хочуть здійснювати продажі онлайн та мають потребу в майданчику для здійснення продажів, контролю замовлень та збору статистики, потребу в сервісі з налагодження логістики, який буде дешевшим та привабливішим для клієнтів за поштові, потребу в способі продажів на замовлення товарів, які швидко псуються чи потребують спеціального температурного режиму для зберігання, потребу в приверненні уваги нових користувачів.
	Основними потребами цільової аудиторії є:
     – швидкий вибір і здійснення замовлення з широкого асортименту товарів різних продавців з пунктом отримання в межах звичного шляху з роботи або неподалік від місця прогулянки;
     – простий та швидкий процес отримання замовлення (з можливістю відмовитися від отримання);
     – єдина система управління асортиментом, запасами на складі;
     – налагодження логістики з доставки інтернет-замовлень;
     – єдина система контролю інтернет-продажів зі збором статистики щодо здійснених за певний період покупок у різних точках.
До потреб цільового ринку можна віднести:
     – вирізнення свого магазину/мережі магазинів серед інших через наявність зручної системи для інтернет-шопінгу;
     – економію коштів на логістику (у доставці може бути задіяний один працівник, який збиратиме замовлення та закладатиме їх у відповідні комірки, можлива інтеграція роботизованої системи доставки);
     – удосконалення якості надання послуг клієнтам, збільшення кількості постійних покупців, збільшення прибутків;
     – усунення витрат на організацію власних точок чи кас видачі інтернет-замовлень;
     – усунення витрат на створення власних програмних систем для здійснення продажів онлайн.

2.3 Припущення та залежності

     Із розвитком програмної системи можливі зміни функціональних можливостей, але залежності та допущення на початку роботи були такими:
     – користувач уміє користуватися браузером та мобільними пристроями, завантажувати додатки;
     – працівник магазину має доступ до мобільного телефону та інтернету під час роботи;
     – браузер встановлено на комп’ютері менеджерів компаній;
     – мобільні телефони замовників та працівників магазинів використовують Android SDK level 18 або вище;
     – в точках, де встановлені розумні точки видачі, користувачі мають доступ до інтернету;
     – точка видачі має постійне надійне з’єднання з інтернетом;
     – інтерфейс роботизованих сервісів доставки є схожим та підтримує зв’язок за допомогою HTTP-запитів, авторизацію за допомогою jwt-токенів;
     – компанія-підписниця самостійно зареєструє кожного з роботів-доставників в системі як своїх працівників.

     2.4 Основний функціонал та сценарії використання системи
     
     Основні можливості системи такі: 
     – авторизація чи реєстрація користувача в певній ролі (працівник компанії, клієнт, системний адміністратор, адміністратор);
     – формування онлайн-замовлення в додатку (вибір з асортименту, наданого компаніями-підписницями);
     – вибір позицій наступного замовлення серед переліку персоналізованих пропозицій;
     – замовлення доставки товарів в обрану точку видачі з автоматичним добором комірки, що забезпечить належні умови зберігання (необхідний температурний режим);
     – віддалене керування точкою видачі та її окремими комірками;
     – додавання компанією в систему позицій асортименту;
     – оновлення компанією інформації про товари та їхню кількість на складі;
     – подання компанією заявок на встановлення розумних точок видачі заданої конфігурації в їхніх магазинах або обраних точках мапи та контроль стану виконання заявки;
     – подання компанією заявок на  деінсталяцію та вилучення з системи точок видачі;
     – управління станом обробки та доставки замовлення, можливість залучення доставників-роботів;
     – отримання клієнтом замовлення або оформлення відмови від нього;
     – автоматичний контроль стану точок видачі та комірок точок видачі, генерація заявок на проведення технічного огляду;
     – збір та виведення статистики для організацій (щодо використання точок видачі для виконання замовлень за різними категоріями товарів) та для адміністратора (щодо інтенсивності використання системи з виведення м відповідного рівня оплати за підписку);
     – керування адміністратором користувачами системи (щодо блокування та розблокування їхніх можливостей), опрацювання заявок на встановлення та деінсталяцію точок видачі, на проведення технічного огляду розумних пристроїв, налаштування нових систем видачі;
     – забезпечення захисту персональних даних користувачів;
     – керування системним адміністратором резервним копіюванням та відновленням даних;
     – надання української або англійської локалізації інтерфейсу програмної системи.
     Для упорядкування  функціоналу відповідно до запланованих ролей користувача було створено UML-діаграму прецедентів (див. додаток А). На ній зображено 5 користувачів за ролями: менеджер компанії-підписниці системи, працівник компанії-підписниці системи, клієнт (замовник), адміністратор (для управління бізнес-логікою) та системний адміністратор. 
     
     2.5 Ризики програмної системи
     
     До ризиків для успішності реалізованої програмної системи можна віднести появу аналогів на ринку (ймовірність = 0.3; важливість = 8). Для уникнення ризику необхідно збирати фідбек від користувачів системи, моніторити системи зі схожим функціоналом та одразу впроваджувати зміни, що покращують продукт, таким чином здобуваючи монополію на ринку.
     Також варто мати на увазі ризик вандалізму (ймовірність = 0.05; важливість = 8). Для зменшення ризику необхідно встановити камери та наліпити відповідні попереджувальні таблички на точки видачі. 
     Існує імовірність того, що система не буде сприйнята клієнтами (ймовірність = 0.2; важливість = 10). Для уникнення ризику необхідно провести інформаційну кампанію в соцмережах, зробити поштові розсилки та презентації потенційним великим клієнтам перед виходом на кожен ринок, запровадити зацікавленим безкоштовний тестовий період на 2 тижні. 
     
     2.6 Обмеження та винятки
     
     При створенні програмної системи прийнято рішення, що накладають такі обмеження:
     – використовуються тестові дані, оскільки не існує реальних пристроїв;
     – передбачається лише бронювання, без здійснення оплати;
     – швидкість серверів обмежена ресурсами серверів Azure для навчання;
     – менеджер не може видалити свій акаунт, акаунт можна лише заблокувати з можливістю подальшого розблокування та відновлення;
     – до опису товарів не додаються фото;
     – застосунок доступний лише для користувачів Android.

     2.7 Вимоги до програмної системи та стек технологій

     Серверна частина додатку повинна мати багаторівневу архітектуру, що включатиме до себе рівні представлення, бізнес логіки та доступу до даних [4]. Основними задачами серверної частини є:
     – управління логікою роботи з сесіями користувачів (реєстрація, авторизація, використання jwt-tokens);
     – створення, перегляд, зміна та видалення даних про асортимент магазинів чи інших бізнесів-підписників;
     – додавання, перегляд, зміна та видалення даних про магазини;
     – створення, розгляд адміністратором, зміна та відстеження стану заявок на встановлення чи деінсталяцію систем комірок;
     – створення та зміна необхідної конфігурації системи комірок;
     – управління користувачами системи (блокування/розблокування);
     – управління резервним копіюванням даних системи;
     – створення замовлення та відстеження його стану;
     – передача аналітичих даних (статистики щодо використання та заявок на технічну підтримку) від розумних пристроїв до клієнтів;
     – обчислення статистики щодо використання бізнесами систем видачі, обчислення вартості підписки та зведення звітів для адміністраторів системи;
     – надання програмного інтерфейсу для взаємодії з системою роботів-доставників: авторизація робота як доставника від компанії підписника, отримання роботом інформації про необхідність здійснення доставки, деталей щодо замовлення і пункту призначення, кодів для відкриття необхідних комірок точок видачі;
     – шифрування приватної інформації користувачів.
     Клієнтська частина має представляти функціонал серверної частини, пов’язаний з управлінням асортиментом, доступним до замовлення, керуванням менеджерами компаній своєю інформацією в системі та управлінням процесом замовлення, встановлення, змін конфігурації та відмов від користування точками видачі, адміністративними можливостями у простому для сприйняття вигляді для кінцевого користувача. Користувачі системи мають отримати можливість авторизуватися за допомогою email та паролю, переглянути інформаційну сторінку. Далі відповідно до ролі користувача має змінитися функціонал:
     – для менеджера компанії-підписника доступне управління інформацією про компанію (магазин) та його асортимент, товари на складі, подання та моніторинг заявок на встановлення чи деінсталяцію точок видачі в зазначених місцях та заданої конфігурації, перегляд статистики щодо використання точок видачі в клієнтських замовленнях;
     – для адміністратора мають бути представлені функції управління користувачами, відповіді на заявки стосовно точок видачі, управління точками видачі (налаштування для підключення до системи, розгляд автоматично згенерованих заявок на технічну підтримку пристроїв), перегляд статистики користування компаніями-підписниками системою;
     – системний адміністратор отримає доступ до управління даними системи: створення бекапів та відновлення з них;
     Інтерфейс клієнта має бути адаптивним, підтримувати локалізацію (українська та англійська мови) для його елементів.
     Мобільний застосунок форматом найбільш вдало підходить для здійснення покупок та формування замовлень «на ходу»: перегляду асортименту магазинів в обраній категорії товарів, пошуку найближчих або найзручніших точок видачі, оформлення онлайн-замовлення та для «комунікації» зі смарт-пристроєм (видача замовлення, підтвердження отримання, оформлення відмови від змовлення). Для працівника компанії-підписника мобільний застосунок міститиме інформацію про замовлення та їхній стан виконання, необхідність здійснити доставку, суми продажів, надаватиме функціонал відправлення звіту про доставку з оновленням інформації про замовлення. 
     Інтерфейс мобільного застосунку також має бути адаптивним, підтримувати локалізацію (українську та англійську) для його елементів.
     IoT інформаційної системи є розумна точка видачі (розумний постамат), яка складається з багатьох комірок різної конфігурації. Кожна комірка матиме власні датчики та методи аналізу їхніх даних. Основна програма точки видачі має збирати аналітичні дані та результати обчислень від усіх комірок (інформацію про завершене чи нове замовлення, коди відкриття, заявки на технічну підтримку) та спрямовує до ендпоінтів серверного застосунку, щоб інформацію отримали адміністратор або менеджер компанії підписника, оновився стан замовлення в базі даних. Процес відбувається через інтернет-підключення. На сервері дані обробляються, а результати відображаються клієнтам у веб- та мобільному клієнті.
     Програмне забезпечення окремої комірки залежно від її налаштувань (чи містить вона контроль за температурою, які границі нормальної температури, яка максимальна кількість відкриття дверцят комірки до проведення технічного огляду) стежить за станом комірки – і якщо температура перевищує або є нижчою за допустиму, адміністратору надсилається відповідне повідомлення. Пристрій також контролює кількість відкривань дверцят – після кожних N генерується повідомлення про необхідність перевірки точки видачі. Після відкриття  в разі, якщо клієнт не заблокував двері через додаток, замок буде заблоковано автоматично за 2 хвилини. 
     Значення параметрів комірок необхідно встановити експериментально, тож в панелі адміністрування пристрою користувач, авторизований як адміністратор чи менеджер, зможе їх змінювати. 
     Програмна система загалом має складатися з серверної частини, створеної мовою C# (платформа .NET 7, ASP.NET Core, REST API, OData). У якості бази даних планується використати MS SQL Server. Веб-клієнт буде виконано за допомогою Angular Framework 17 із використанням мови програмування TypeScript. Мобільний застосунок використовуватиме технологію Java Android (Android SDK, minimum SDK – API 24: Android 7.0). IoT будуватиметься на апаратній базі контролера Raspberry Pi, який підтримує виконання коду на C# та доступ до Інтернету. На пристрої має бути встановлено .NET Core, планується розробка міні-сервера з використанням технології ASP.NET Core, який підтримує зв’язок з системою за допомогою HTTP-запитів (із використанням HttpClient). Як локальне сховище параметрів, для яких можливе адміністрування при запуску девайсу, використовуватиметься файл.
     Такий стек дозволить розробити продукт, який буде легко масштабувати та підтримувати. 
     
     


     3 АРХІТЕКТУРА Й ПРОЄКТУВАННЯ СИСТЕМИ
     3.1 UML-моделювання
     
     Процес проєктування програмної системи було розпочато із детального моделювання поведінки системи та її окремих складових, сценаріїв її використання мовою UML. UML було обрано зважаючи на те, що ця мова є найбільш популярною для проєктування та є безліч безкоштовних інструментів для моделювання, також саме UML-діаграми дозволяють описати систему в такому вигляді, який у подальшому легко переписати як програмний код [6].
     Першою було змодельовано діаграму прецедентів для системи вцілому (див. додаток А) для того, щоб описати схематично сценарії використання системи користувачами в різних ролях. Було виділено 5 «акторів» – адміністратора системи з точки зору бізнес-логіки (для управління користувачами, організаціями та точками видачі), системного адміністратора (який керує даними в системі), клієнта-замовника (людину, яка хоче здійснити інтернет-покупку), менеджера компанії-підписниці системи (який управляє даними про компанію, її асортимент та точки видачі в системі) та працівника компанії-підписниці системи (який опрацьовує замовлення та здійснює доставки).
     Далі було змодельовано діаграми станів для складних процесів бізнес-логіки. Наприклад, для опису процесу встановлення точки видачі (див. додаток Б), до якого залучено декілька користувачів (менеджер компанії-підписниці та адміністратор системи) на різних етапах розгортання процесу.
     
     3.2 Проєктування бази даних
     
     Після UML моделювання за підходом «code first» було створено модель бази даних, що передбачало створення доменних моделей та атрибутів полів у серверному застосунку системи, з подальшим створенням відповідних таблиць та зв’язків між ними в базі даних за допомогою системи міграцій. 
     Таким чином було використано і перевагу гнучкої розробки системи, оскільки є можливість легко та оперативно реагувати на зміни до вимог до програми. 
     Для побудови реляційної бази даних спершу було створено ER-діаграму (див. додаток В), усього вийшло 13 сутностей зі зв’язками один-до-багатьох та один-до-одного. Таблиці бази даних при створенні діаграми було приведено до 3 нормальної форми. У результаті була отримана модель бази даних, що повністю відповідає вимогам даної системи і загальним практикам створення схем баз даних. 
     У створеній базі даних також існує таблиця __EFMigrationsHistory, що потрібна для контролю міграцій та IssuedTokens для тимчасового зберігання токенів та токенів для оновлення.
     
     3.3 Загальна архітектура програмної системи
     
	Розроблена програмна система мітить чотири складові: серверний застосунок, веб-клієнт, мобільний застосунок та IoТ-застосунок. Робота системи базується на постійній взаємодії цих частин, а функціонал є наскрізним (наприклад, отримання замовлення ініціюється в мобільному клієнті, опрацьовується в серверному застосунку, серверний застосунок ініціює оновлення стану ІоТ-частини, ІоТ-застосунок надає відповідь, яка повертається для відображення в мобільному клієнті через серверний застосунок і можливо ІоТ-застосунок також формує запит на технічну підтримку пристрою, яка має відообразитися на веб-клієнті, пройшовши етап опрацювання в серверному застосунку). 
	Кожна частина використовує різні технології та розгортається в різному середовищі. Компоненти взаємодіють між собою через протоколи HTTP та OData. Серверний застосунок (backend) є основою системи, в його сервісах обробляються всі основні операції за бізнес-логікою, операції маніпуляцій з даними системи, аутентифікація та авторизація. Застосунок використовує OData як протокол для стандартних CRUD-операцій. Це спрощує доступ до даних і полегшує інтеграцію з різними клієнтами.
     HTTP використовується як транспортний протокол для передачі даних між сервером та клієнтами (мобільним, веб- та ІоТ-застосунками).
     Перевагами такої архітектури є модульність, яка дозволяє легше масштабувати та розширювати систему, стандартизована взаємодія між компонентами завдяки HTTP та OData для спрощення інтеграції та підтримки системи в подальшому, гнучкість у розробці, оскільки частини системи можуть розроблюватися, підтримуватися та тестуватися окремо, та безпека компонентів системи завдяки авторизації та аутентифікації на серверному рівні.
     
3.4  Архітектура серверної частини

     Серверна частина додатку, розроблена з використанням ASP.NET Web API має багаторівневу Onion-архітектуру, що включає рівні представлення, сервісів, бізнес логіки та доступу до даних (див. додаток Г). 
     EnRoute.API складається з контролерів, валідаторів та методів запуску сервера. EnRoute.Domain містить доменні моделі та контекст Entity Framework (див. додаток Д) для доступу даних. EnRoute.Infrastructure містить необхідні для роботи системи сервіси, константи, методи розширення. EnRoute.Common складається з констант та моделей конфігурації. 
     Систему загалом представлено у архітектурному стилі клієнт-сервер, дотримано архітектурний стиль REST (серверний застосунок не зберігає стан) за стандартами OData. 
     У серверному застосунку використано патерни Dependency Injection, Unit of Work, Iterator та Strategy Factory.



     3.5 Архітектура веб-клієнта
     
     Для розробки клієнтської (frontend) частини проєкту було обрано веб-фреймворк Angular, призначений для створення ефективних односторінкових застосунків (Single Page Applications) та мову програмування TypeScript для забезпечення статичної типізації коду, яка підвищує надійність програми. Використано версії  Angular CLI 17.1.1 та Node 18.17.0.
     Angular використовує компоненти як основні блоки побудови застосунків. Кожен компонент відповідає за окрему частину користувацького інтерфейсу: авторизацію, реєстрацію, додавання нової страви тощо. Компоненти, моделі та сервіси можна відповідно згрупувати для кращого управління кодом (наприклад, у розробленому проєкті об’єднані сервіс авторизації, роботи з JWT-токенами, DTO для авторизації та відповідні компоненти).
     Функції двостороннього зв'язування (Two-Way Data Binding), вбудовані у фреймворк, дозволяють автоматично оновлювати дані в користувацькому інтерфейсі, якщо вони змінюються в ході виконання функцій застосунку. Це суттєво пришвидшує роботу з введенням та виведенням даних.
     Angular підтримує асинхронну взаємодію з сервером за допомогою HTTP-запитів (з використанням HttpClient для взаємодії з RESTful API), дозволяючи отримувати та надсилати дані до сервера асинхронно. Також використано RxJS використовувався для ефективної обробки асинхронних подій та керування потоками даних.
     Використані технології забезпечили високу продуктивність, надійність і зручність управління кодом у процесі розробки та підключення до системи веб-клієнта.
     При запуску застосунку першим виконується файл main.ts. Цей файл містить точку входу для виконання коду:
      1 import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
      2 import { AppModule } from './app/app.module';
      3 
      4 platformBrowserDynamic().bootstrapModule(AppModule)
      5   .catch(err => console.error(err));
     Після виконання файлу main.ts керування передається основному модулю AppModule, в якому визначено всі компоненти, сервіси, директиви та бібліотеки, які використовуються для роботи застосунку.
     Angular будує дерево компонент, використовуючи інформацію з AppModule. Після побудови з дерева компонент обирається коренева – AppComponent і розпочинається виконання додатку з додаванням кореневої компоненти у DOM.
     Життєвий цикл кожної компоненти починається з виконанння ngOnInit, наприклад, в AppComponent першочергово перевіряється, чи в локальному сховищі вже записано дані про користувача з попередньої авторизації, чи необхідно виконати повторну:
      1 ngOnInit() {
      2   this.authService.loadUserFromLocalStorage();
      3 }
     Angular відслідковує зміни в даних та автоматично оновлює відображення в DOM.
     Кожна компонента застосунку складається із чотирьох файлів: розмітки HTML, стилів CSS, файлу TypeScript із логікою та файлу для тестування.
     AppComponent керує автоматичним підвантаженням компоненти, на яку вказує посилання, обране користувачем в процесі взаємодії з застосунком. При цьому компоненти «шапки» та «підвалу» залишаються сталими:
      1 <app-header></app-header>
      2 <router-outlet></router-outlet>
      3 <app-footer></app-footer>
     В проєкті використано селектори, визначені для всіх компонент для включення у шаблони інших компонент. Управління шляхами здійснюється в app-routing.module.ts (див. додаток E).
     
     3.6 Архітектура ІоТ
     
     Для розробки програмного забезпечення для «розумного» пристрою «Розумна точка видачі інтернет-замовлень» було обрано технологію .NET Core. За основу пристрою, для якого створюємо програмне забезпечення, взято Raspberry Pi.
     Raspberry Pi зазвичай використовується для створення малих, потужних комп'ютерів, і його можна використовувати для розгортання та запуску веб-додатків. Операційною системою для Raspberry Pi є Linux. ASP.NET Core – це фреймворк для розробки веб-додатків, який підтримує кросплатформенність – його можна використовувати на операційній системі Linux. 
     Програмне забезпечення для «розумної» точки видачі складається з двох основних частин – для контролю стану пристрою (на основі даних від комірок) та для обчислення статистичних даних щодо наповнення та замовлень, отриманих через комірки точки видачі. Результати обчислень серіалізуються та записуються у файлове сховище. За користувацьким запитом дані через серверну частину повертаються на веб-клієнт. 
     Розумний пристрій самостійно контролює свій стан відповідно до заданих при запуску параметрів – діапазону нормальних температур всередині комірок (контролюється для комірок з підтримкою особливого температурного режиму) та кількості відкривань дверцят (забраних замовлень) з останнього технічного огляду. Для цього в проєкті створено сервіс контролю температури, який щопівгодини імітує зчитування з датчиків всередині комірок значення температури, звіряє з допустимим та в разі невідповідності якогось з отриманих показників нормі формує запит на технічну підтримку; та контролер запитів на технічний огляд, який відповідає за зчитування та збереження даних щодо відкриття комірок (у разі перевищення допустимого значення формується запит на технічну підтримку), формує та надсилає запити на серверний застосунок, отримує відповіді від сервера стосовно проведення огляду та оновлює (скидає) значення в комірці.
     Пристрій веде облік замовлень, забраних із комірок, обчислює та зберігає статистику продажів, яку надає за запитом адміністратора. Для цього створено окремий контролер з необхідними обчисленнями та методами доступу.
     У проєкті наявні файли моделей, які використовуються при роботі програмного забезпечення: запита на підтримку, статистики та замовлення.
     Використано файли .json для локалізації застосунку: англійської та української. Запуск сервісів та контролерів, адміністрування та налаштування відбувається в головному файлі програми (Program.cs).
     
     3.7 Архітектура мобільного клієнта
     
     Для розробки мобільного застосунку для проєкту було обрано середовище Android Studio з використанням мови програмування Java. 
     Проєкт створено з налаштуванням на підтримку мінімальної версії Android API 24 (Android 7.0), цільовою ж обрано Android API 33 (Android 13). Такі конфігурації рекомендовані Google Play з 31.08.2023 та дозволяють запуск та роботу застосунка на 96,3% Android-пристроїв, які наразі використовуються [7].
     У проєкті використано Java 8, оскільки це версія, яка повністю підтримується Android, плагін Android Gradle для оптимізації роботи засобів збірки, бібліотеку AndroidX для покращеної підтримки фрагментів та активностей. Бібліотеку Material Design Components використано для створення зручного інтерфейсу користувача згідно з принципами Material Design. Для виконання HTTP-запитів та отримання відповідей використано OkHttp. Для зручного фільтрування та «розширення» результатів виконання запитів використано протокол OData.
     Використані технології забезпечили високу продуктивність, надійність і зручність управління кодом у процесі розробки та підключення до системи мобільного клієнта.
     Проєкт складається з «вікон» (актівіті, яких налічується 7), доменних моделей та DTO (моделей для виконання запитів), сервісів, які містять логіку для обробки даних, утиліт із допоміжними функціями для роботи з даними, ресурсних фалів (файлів розмітки, рядків, зображень, шрифтів, окремих загальних елементів розмітки), скриптів Gradle, які містять налаштування проєкту та підключених бібліотек.
     Файли вікон розділені за логічним призначенням: загального користування, призначені для клієнта, призначені для доставника або менеджера компанії-підписниці системи. У кожного Activity файлу є відповідний layout файл (.xml), на якому налаштовано вигляд вікна. Ці файли знаходяться в папці res/layout.
     Сервіси також знаходяться в окремій директорії. Наявні сервіс авторизації, для роботи з JWT, створення фабрики HttpClient, сервіси для роботи з даними клієнта, постачальника, відомостями про страви, філіали та замовлення, сервіс побудови запитів OData.
     У директорії моделей наявні доменні моделі товару, позиції замовлення, категорії та виробника товару, комірки точки видачі та точки видачі, користувача, замовлення, організації та її співробітника. Окремо збережено моделі для запитів – DTO для авторизації та реєстрації. Директорія з константами містить відомості про базове посилання на сервер, назви endpoint для базового контролера OData на сервері, перелік статусів (етапів прийняття та виконання) замовлення.
     Наявна директорія для інтерсепторів (див. додаток Ж), які «перехоплюють» запити та додають до них заголовок із даними авторизації, оновлюють токен на основі токена для оновлення в разі закінчення його дії.
     Допоміжні функції та утиліти: для роботи з датами, приведення їх до формату відповідно до локалі – також зберігаються в окремій директорії.
     Ресурсні файли поділяються за призначенням. В окремих директоріях зберігаються файли з розміткою, файли компонентів розмітки, графічні зображення, файли зі значеннями використаних кольорів та тем, файли встановлених шрифтів та файли рядків відповідно до локалі.
     Взаємодія користувача із застосунком розпочинається з відкриття MainActivity, в якій він обирає подальший шлях ¬– реєстрацію в RegistrationActivity,  або авторизацію (LoginActivity).
     Після авторизації відповідно до ролі користувача йому відкривається подальший функціонал:
      01 if (response != null) {
      02   User user = AuthService.getInstance(this).getUser();
      03   Intent intent;
      04   String role = user.getRoles();
      05   if (role.equals(String.valueOf(Role.customer)))
      06   {
      07       intent = new Intent(LoginActivity.this, CustomerHomeActivity.class);
      08   }
      09   else {
      10       intent = new Intent(LoginActivity.this, ShopManagerHomeActivity.class);
      11   }
      12 
      13   startActivity(intent);
      14   finish();
      15 }
     Для користувача в ролі клієнта доступні активіті для перегляду персоналізованих рекомендацій (RecommendationsActivity) для здійснення замовлення (на основі попередніх замовлень користувача обираються «улюблені» пропозиції, наявні на складах в магазинах), активіті перегляду стану замовлень (CustomerHomeActivity), здійснення відкриття комірки для отримання замовлення, активіті формування нового замовлення (MakeOrderActivity).
     В ролі менеджера компанії-підписниці системи користувач може відстежувати замовлення в його магазині, взаємодіяти з комірками точки видачі для здійснення доставки замовлень, формувати звіти про доставку.


4 ОПИС ПРОГРАМНИХ РІШЕНЬ
     4.1 Програмні рішення серверного застосунку
     4.1.1 Робота з базою даних
     
     Як базу даних було обрано реляційну в MS SQL Server. Вона легко інтегрується з мовою програмування C#, обраною для реалізації застосунку, база добре масштабована й потенційно може бути інтегрована з Azure. 
     Для роботи з базою даних було обрано Entity Framework Core. Як метод створення моделі бази даних обрано підхід Code First – спершу було описано об’єкти мовою C#: створено доменні моделі та контекст бази даних (див. додаток Д). Моделі описують сутності (таблиці) та зв’язки між ними, за допомогою атрибутів було задано необхідні обмеження: обмеження унікальності, допустимості та недопустимості відсутніх значень, обмеження за довжинами рядків тощо.
     Для ідентифікаторів моделей використано унікальні ідентифікатори (GUID): це дозволить робити злиття даних із майже гарантованим уникненням проблем із дублюванням ідентифікаторів.
     
     4.1.2 Автентифікація 
     
     Додаток використовує JSON Web Token (JWT) для перевірки автентифікації користувача (див. додаток И). 
     Параметри для генерації токенів записано в appsettings: 
      1 "JwtSettings": {
      2  	"ValidAudience": "http://localhost:4200",
      3 	"ValidIssuer": "http://localhost:5000",
      4 	"Secret": "2sGGZpRfREs0cNp4ZOkgsEl3AIwWr2b1A8ixGPB4XjAxcSbJDXfnYb5T9qaJSPb7",
      5 	"TokenValidityInMinutes": 1,
      6 	"RefreshTokenValidityInDays": 7
      7 }
     Спочатку користувач надсилає запис на авторизацію за допомогою автентифікаційного ключа (адреса електронної пошти та пароль). Потім сервер автентифікації створює JWT та токен для оновлення (refresh token) та відправляє їх користувачеві. Токен для оновлення – це вид токена, який використовується для продовження дії автентифікаційного сеансу користувача. JWT токен має обмежений строк дії, а токен для оновлення – довший термін. Коли JWT токен закінчує свій строк, на сервері за допомогою рефреш токен отримується новий JWT токен без необхідності повторно вводити логін та пароль. Це підвищує безпеку та покращує досвід користувача.
     Коли користувач робить запит до API додатку, він додає до нього раніше отриманий JWT.
     JWT складається з трьох частин: заголовок (header), корисні дані (claims) та підпис (signature). Заголовок JWT містить інформацію про те, як обчислювати підпис JWT. Корисні дані (claims) – це інформація про користувача, яка зберігається всередині токена. У системі сервер створює JWT з інформацією про ідентифікатор користувача, адресу його електронної пошти, дату реєстрації в системі та ім’я:
      1 var authClaims = new List<Claim>
      2 {
      3 	new(JwtClaims.Sub, user.Id.ToString()),
      4 	new(JwtClaims.Email, user.Email!),
      5	new(JwtClaims.RegisterDate, user.RegisterDate.ToString("O")),
      6 	new(JwtClaims.Name, user.Name)
      7}; 
     Далі додається «підпис» з використанням алгоритму HMAC-SHA256. 
      1 signingKey = new SymmetricSecurityKey (Encoding.UTF8.GetBytes (jwtSettings.Secret));
      2 signingCredentials = new SigningCredentials (signingKey, SecurityAlgorithms.HmacSha256);
     Для контролю доступу до контролерів використано атрибут [Authorize] ( див. додаток К) в базовому контролері OData. 
     За кожним користувачем ведеться облік токенів (IssuedTokens): з коротким терміном дії та токенів для оновлення. Дані про токен з коротким терміном дії оновлюються, поки не закінчиться термін дії токену для оновлення. Далі користувачеві необхідно повторно виконати вхід до системи.
     
     4.1.3 Специфікація REST APІ
     
     Для обміну даними з клієнтами використано веб-протокол OData. 
     За принципами REST API реалізовано «базовий контролер» (див. додаток R). Успадкувавши контролер, можна зробити базовий API для будь-якої моделі. 
     Під принципами REST API у контексті роботи з даними мається на увазі відповідність кожного методу HTTP певній дії. Наприклад, для моєї системи це метод POST для створення, PUT для оновлення, DELETE для видалення та GET для отримання запису (див. додаток Л).
     
     4.1.4 Валідація на сервері
     
     Для валідації даних переданих в запитах від клієнтських частин системи в серверному застосунку було використано Fluent Validation. Це бібліотека для валідації даних в .NET-програмах, що надає можливість визначати правила валідації у декларативному стилі. Це дозволяє легко читати і зберігати код валідації. 
     В застосунку було створено валідатори для основних моделей та для запитів на реєстрацію користувачів. Розглянемо визначення деяких правил валідації для моделі запиту на реєстрацію користувача як менеджера організації:
      01 RuleFor(c => c.Password)
      02 .NotEmpty();
      03 RuleFor(c => c.Name)
      04 .NotEmpty()
      05 .MinimumLength(3);
      06 RuleFor(c => c.Role)
      07 .Must(c => 
      08  RolesAllowedForRegistration
      09 .Contains(c.ToLower()))
      10 .WithMessage("Registration role is invalid.");
      11 RuleFor(c => c.Email)
      12 .EmailAddress()
      13 .MustAsync((e, _) => 
      14  dbContext.Users
      15 .AllAsync(u => u.Email != e))
      16 .WithMessage("User with this email already exists.");
     Створено клас RegisterCompanyRequestValidator, який успадковує AbstractValidator – цей базовий клас надає зручний спосіб визначати правила валідації моделі. Метод .RuleFor() використано для визначення правил валідації для полів об'єкта: у прикладі це Password, Name, Role, Email. Методи .Must() та .MustAsync() використано для визначення умов для валідації. В прикладі це: чи значення поля Role міститься в списку RolesAllowedForRegistration, чи вже існує користувач з такою електронною адресою Email в базі даних. Метод .WithMessage() використано для визначення повідомлення про помилку, яке буде повернуто, якщо правило валідації не виконується.
     Якщо валідація пройде успішно, то запит на створення компанії буде оброблено.
     
     4.1.5 Використання механізму Dependency Injection
     
     Для передачі залежностей використано механізм Dependency Injection. Приклад реалізації:
      1 builder.Services.AddSingleton<IJwtTokenService, JwtTokenService>();
      2 builder.Services.AddScoped<IAuthService, AuthService>();
     У наведеному коді наведено два підходи. При використанні AddSingleton при першому запиті створюється один екземпляр сервісу який використовується протягом усього життєвого циклу додатка. При використанні AddScoped створюється новий екземпляр сервісу для кожного HTTP-запиту, який після виконання запиту видаляється.
     Це дозволяє легко змінити залежності в разі потреби, налаштовувати час життя залежності та облегшувати тестування й розуміння коду. 
     
     4.1.6 Забезпечення безпеки даних
     
     Забезпечення безпеки даних у серверному застосунку включає:
     – гешування кодів доступу до комірок та користувацьких паролів, збереження цих даних в базі даних у зашифрованому вигляді;
     – використання ORM фреймворку Entity Framework для запобігання SQL-ін'єкціям;
     – упроваджені аутентифікація і авторизація користувачів за токеном JWT (JSON Web Token). Права доступу користувачів перевіряються перед доступом до конкретних ресурсів (перевіряється правомірність отримання даних користувачем у певній ролі з певного ендпоінта). Кожен користувач має доступ лише до необхідної для його роботи інформації;
     – валідацію всіх вхідних даний та перевірку їх на відповідність очікуваному формату та допустимим значенням за допомогою Fluent validation.

     4.2 Програмні рішення веб-клієнта
     4.2.1 Формування запитів
     
     В розроблюваній системі було використано протокол OData для створення запитів до серверного застосунку.
     За принципами REST API було реалізовано «базовий сервіс». Успадкувавши сервіс, можна отримати базові операції для будь-якої моделі. 
     У разі, якщо необхідна специфічна логіка: спеціальні фільтри, сортування, «розширення» моделі іншими об’єктами, запит OData формується безпосередньо в специфічному сервісі. Кожна з основних моделей (наприклад, точка видачі, товар, організація тощо) має свій сервіс. Наприклад, ось функція для запиту на отримання усіх товарів компанії:
      1   getAllOrganizationGoods(organizationId: string): Observable<Good[]> {
      2     return this.ODataService.entities()
      3       .query((q) => {
      4           q.expand('producer,category');
      5           q.filter(({ e }) => e().eq('organizationId', organizationId, 'none'))
      6         }
      7       )
      8       .fetch()
      9       .pipe(this.mapODataEntities);
      10   }
     HTTP-клієнт повертає тип даних Observable<T>. Це дозволяє ефективно взаємодіяти з асинхронними запитами та отримувати оновлення стану або результати запитів в реальному часі, «підписавшись» на Observable.
     
     4.2.2 Валідація користувацького введення
     
     У веб застосунку передбачено два етапи валідації: спершу відбувається стандартна перевірка введення за допомогою атрибутів форм required, maxlength та minlength, контролюється тип введених даних (email, text, number). Користувачу за допомогою повідомлень під неправильно заповненим елементом форми виводиться інформаційне повідомлення червоного кольору:
      01 <div class="mt-4 col-12">
      02   <span class="p-float-label">
      03     <textarea id="description" name="description" rows="5" [(ngModel)]="model.description" class="col-12" pInputTextarea
      04       required #descriptionField="ngModel" minlength="10" maxlength="200"></textarea>
      05     <label for="description" i18n> Organization short description</label>
      06   </span>
      07 
      08   <div *ngIf="descriptionField.invalid && (descriptionField.dirty || descriptionField.touched)">
      09     <div *ngIf="descriptionField?.errors?.['required']" class="alert alert-danger col-12" i18n>
      10       Short description is required.
      11     </div>
      12     <div *ngIf="descriptionField?.errors?.['minlength']" class="alert alert-danger col-12" i18n>
      13       Short description should have at least 10 characters.
      14     </div>
      15     <div *ngIf="descriptionField?.errors?.['maxlength']" class="alert alert-danger col-12" i18n>
      16       Short description maximum size is 200 characters.
      17     </div>
      18   </div>
      19 </div>
     Після того, як введення проходить початкову перевірку, розблоковується кнопка надсилання даних.
     Другий етап пов’язаний із використанням директиви ngModel. Вона робить прив’язку користувацького введення до об’єкту, створеного в компоненті. Перед відправленням запиту до сервера цей об’єкт перевіряється функціями для валідації для перевірки відповідності вимогам за бізнес-логікою. Наприклад, чи збігається пароль та повторно введений пароль.
     
     
     
     4.2.3 Локалізація
     
     Веб-клієнт підтримує інтернаціоналізацію та пристосований до двох локалей: української та англійської. 
     При запуску та збиранні застосунку (build) поточна локаль визначається за LOCALE_ID. Вона є частиною Angular Common Module та визначена як один із провайдерів у app.module.ts.
     Усі теги, текст яких має бути перекладеним, помічені атрибутом i18n, повідомлення, які прописані як константні рядки в програмному коді на TypeScript (наприклад, текст для сповіщень про успішність виконання дії) помічені функцією $localize(). Після виконання автоматичного збору всіх рядків, які потребують перекладу, вони переносяться до файлу xlf, який перекладено для кожної локалі. Дані текстові дані вибираються з файлу, який відповідає поточній локалі, за унікальним ідентифікатором рядка:
      1 <trans-unit id="7000649363168371045" datatype="html">
      2   <source>Save changes</source>
      3   <target>Зберегти зміни</target>
      4   <context-group purpose="location">
      5     <context context-type="sourcefile"> src/app/features/organization/assortment-management/edit-product/edit-product.component.html </context>
      6     <context context-type="linenumber">88</context>
      7   </context-group>
      8 </trans-unit>
     Важливим для веб-застосунку є також відображення дат та часу відповідно до локалі. Для цього дані про дату та час, отримані з сервера в форматі UTC, приводяться у відповідність локалі за допомогою date pipe.
     За допомогою компонентів PrimeNG локалізується також виведення грошових сум. Грошова одиниця змінюється на гривню чи долар відповідно до локалі.
     
     4.2.4 Користувацький інтерфейс
     
     На головній сторінці застосунку відображено інформацію про систему. Залежно від локалі відображення англійською або українською мовою. Таку сторінку бачить не авторизований користувач (рис. 4.2.1).
     

Рисунок 4.2.1 – Головна сторінка веб-клієнта EnRoute

	Щоб отримати доступ до функціоналу потрібно авторизуватися в системі – зареєструватися (рис. 4.2.2) або увійти в існуючий акаунт (рис. 4.2.3) На формах є валідація, підказки користувачеві, кольорова індикація коректності дій.


Рисунок 4.2.2 – Форма реєстрації

Рисунок 4.2.3 – Сторінка авторизації

	Далі залежно від ролі авторизованого користувача доступний функціонал і вигляд веб-сайту змінюється. Менеджер компанії-підписниці системи переходить до управління асортиментом, запасами на складі та точками видачі в системі (рис. 4.2.4).


Рисунок 4.2.4 – Вигляд компоненту з опціями для менеджера компанії

	Адміністратор системи отримує доступ до функціоналу управління користувачами, організаціями, запитами на технічну підтримку та точками видачі в системі (рис. 2.4.5).

Рисунок 4.2.5 – Вигляд компоненту з опціями для адміністратора системи

	Системний адміністратор отримує доступ до компоненту управління даними та резервними копіями даних системи (рис. 2.4.6).


Рисунок 4.2.6 – Вигляд компоненту з опціями для системного адміністратора

	Отже, компоненти спроєктовано під окремі ролі користувачів та необхідний функціонал.


	4.3 Програмні рішення ІоТ-застосунку
	4.3.1 Формування запитів

	Програмне забезпечення для «розумної» точки видачі є повнозначною частиною складної системи. 
     Застосунок самостійно контролює стан пристрою, опрацьовуючи дані з комірок, веде облік статистики. Серверній частині пристрій надсилає сформовані запити на технічну підтримку: із причин критичної температури або перевищення кількості відкриття дверцят комірки. 
     На клієнтський запит програма  надсилає статистичні дані стосовно виручки, товарів-лідерів продажу та найпопулярніших категорій товарів серед виданих замовлень. 
     Від серверної частини застосунок отримує замовлення, сповіщення про необхідність видачі замовлення та команду на скидання значень до нормальних після технічного огляду. 
     Обмін інформацією реалізовано за допомогою HttpClient, який приймає базову адресу сервера:
      01 private async void SendTechInspectionRequest(int currentCount)
      02 {
      03     var client = httpClientFactory.CreateClient();
      04     var baseUri = new Uri(configuration.GetValue<string> ("ServerUrl"));
      05     client.Timeout = TimeSpan.FromMinutes(5);
      06 
      07     var response = await client.PostAsJsonAsync(new Uri (baseUri, "odata/TechInspectionRequests"), new TechInspectionRequest
      08     {
      09         Temperature = new TemperatureService (httpClientFactory, settings, configuration).GetTemperature(),
      10         OpensCount = currentCount
      11     });
      12 }
     Запити від пристрою містять його унікальний ідентифікатор, який вводиться при налаштуванні пристрою.
     URI пристрою в системі задається адміністратором при наданні дозволу на  встановлення холодильника.

	4.3.2 Локалізація

     Програмне забезпечення має механізм локалізації для адаптації інтерфейсу користувача до обраної локалі (українська або англійська). 
     Функція GetUserLocale() запитує користувача про обрану мову. Функція LoadLocalizationResource(string locale) завантажує ресурси локалізації з файлу JSON відповідно до вибраної мови користувача. 
     Для завантаження ресурсів локалізації виконано обробку винятків із виведенням відповідних до помилки повідомлень:
      01     try
      02     {
      03         string json = File.ReadAllText(localizationFileName);
      04         resource = JsonSerializer .Deserialize<Dictionary<string, string>>(json);
      05     }
      06     catch (FileNotFoundException)
      07     {
      08         Console.WriteLine($"Localization file '{localizationFileName}' not found. Using default locale.");
      09         string defaultLocalizationFileName = "English.json";
      10         string json = File .ReadAllText(defaultLocalizationFileName);
      11         resource = JsonSerializer .Deserialize<Dictionary<string, string>>(json);
      12     }
      13     catch (Exception ex)
      14     {
      15         Console.WriteLine($"Error loading localization: {ex.Message}");
      16     }
     Якщо файл локалізації не знайдено, використовується файл локалізації за замовчуванням «English.json».
     Встановлення певної локалі також передбачає зміну одиниць виміру на зручні для користувача. Для української локалі температура зчитується в градусах Цельсія (рис. 4.3.1), для англійської – у Фаренгейтах (рис. 4.3.2).
     

Рисунок 4.3.2  Інтерфейс налаштування смарт-пристрою 
для української локалі
     

Рисунок 4.3.2  Інтерфейс налаштування смарт-пристрою 
для англійської локалі
     
     Серверний застосунок отримує дані в градусах Цельсія, переведення відбувається перед відправкою запиту.
        
        
        
        
	4.3.3 Обчислення статистики

     Програмне забезпечення формує статистику замовлень, отриманих через комірки точки видачі (див. додаток Г). Дані оновлюються після кожного відкриття комірки на видачу замовлення. 
     Обчислюється виручка, підбивається підсумок щодо найбільш популярних товарів у замовленнях, вираховується найбільш популярна категорія товарів у певній точці видачі. Після обчислення дані статистики записуються в об’єкт та серіалізуються для запису в файл.
     Актуальні статистичні дані десеріалізуються та надсилаються на веб-клієнт за користувацьким запитом GET.

	4.3.4 Адміністрування пристрою

     Налаштування програмного забезпечення відбувається при його запуску. Процес налаштування може відбуватися обраною користувачем мовою, уведення валідується. 
     Під час налаштування необхідно задати параметри для відстеження пристроєм свого стану та унікальний ідентифікатор пристрою для формування запитів до сервера:
      1 public record CounterSettings(string id, Locale locale, int MaxDoorOpenCount, double MinCellTempC, double MaxCellTempC);

	4.4 Програмні рішення мобільного клієнта
	4.4.1 Формування запитів

     В розроблюваній системі було використано протокол OData для створення запитів до серверного застосунку.
     За принципами REST API було реалізовано «базовий сервіс». Сервіс надає базову логіку побудови запитів для будь-якої моделі. Для коректної роботи сервісу також було підключено бібліотеку Gson, яка дозволяє серіалізувати та десеріалізувати дані при роботі з JSON.
     У разі, якщо необхідна специфічна логіка: спеціальні фільтри, сортування, «розширення» моделі іншими об’єктами, запит OData формується безпосередньо в специфічному сервісі. Кожна з основних моделей (наприклад, замовлення, товар) має свій сервіс. Наприклад, ось функція для запиту на отримання всіх точок видачі за конкретною організацією зареєстрованою в системі:
      01   public List<PickupCounter> getOrganizationsCounters(UUID organizationId) {
      02      List<PickupCounter> counters = new ArrayList<>();
      03      ODataService<PickupCounter> t = new ODataService <PickupCounter>(PickupCounter.class, context);
      04      ODataQueryBuilder builder = new ODataQueryBuilder();
      05      builder.filter("OrganizationId eq " + organizationId.toString());
      06
      07      try {
      08          counters = t.getAll(ODataEndpointsNames .PICKUP_COUNTERS, builder);
      09      } catch (IOException e) {
      10      }
      11 
      12      return counters;
      13  } 
     В застосунку реалізовано HttpClientFactory для використання OkHttpClient за патерном Singletone для оптимізації використання ресурсів.

	4.4.2 Автентифікація

     Система використовує використовує JSON Web Token (JWT) для перевірки аутентифікації користувача та визначення його ролі за відповіддю сервера.
     Користувач у LoginActivity надсилає запит на авторизацію за допомогою аутентифікаційного ключа (адреса електронної пошти та пароль). На сервері створюється створює JWT та токен для оновлення (refresh token), які отримує мобільний клієнт. Коли JWT токен закінчує свій строк, на сервері за допомогою рефреш токена генерується новий JWT токен без необхідності повторно вводити логін та пароль. Це підвищує безпеку та покращує досвід користувача.
     Коли користувач робить запит до API додатку, запит «перехоплює» AuthInterceptor та додає до його заголовку токени, цей інтерсептор також стежить за необхідністю оновлення токена та відправляє відповідний запит на сервер. 
     JWT складається з трьох частин: заголовок (header), корисні дані (claims) та підпис (signature). Заголовок JWT містить інформацію про те, як обчислювати підпис JWT. Корисні дані (claims) – це інформація про користувача, яка зберігається всередині токена. 
     За авторизацію в певній ролі, збереження даних про користувача та завершення сесій відповідає AuthService. TokenStorageService містить функції для роботи з токенами – отримання та запису інформації з них. 
     Функціонал застосунку змінюється залежно від ролі авторизованого користувача користувача.

	4.4.3 Локалізація

     Для вирішення задачі локалізації були використані стандартні можливості платформи Android, що змінюють локалізацію додатку у відповідності до налаштувань мови на пристрої.
     У проєкті використано xml файли локалізації res/values/strings.xml та res/values-uk/strings.xml. У файлах зібрано всі текстові дані застосунку, включно із повідомленнями, підказками та сповіщеннями.
     Для того, щоб використати рядок в програмі, він «викликається» за своїм ідентифікатором:
      1 private String makeFullDescription(Order order) {
      2     return getResources()
      3            .getString(R.string.about_order) 
      4            + ": "
      5            + order.toString();
      6 }

	4.4.4 Користувацький інтерфейс

	Інтерфейс та, відповідно, функціонал користувача різниться відповідно до його ролі після авторизації. Першим активіті, що бачить користувач по відкриттю застосунку, є меню вибору подальшої дії  авторизація чи реєстрація (див. рис. 4.4.1).


Рисунок 4.4.1  Стартовий екран мобільного застосунку
для англійської локалі

     Якщо користувач обирає реєстрацію в застосунку  він переходить на форму реєстрації як клієнта системи EnRoute (див. рис. 4.4.2). 
        

Рисунок 4.4.2  Форма реєстрації клієнта в системі EnRoute

     Наступною формою по реєстрації буде форма авторизації, до якої також можна перейти із головної сторінки застосунку, якщо клієнт вже має дані для входу в систему (див. рис. 4.4.3). Для авторизації достатньо ввести електронну пошту (унікальне поле) та відповідний пароль.


Рисунок 4.4.3  Форма авторизації клієнта або працівника магазину 
в системі EnRoute

     Подальший шлях користувача залежить від його ролі. Клієнт, що бажає здійснювати онлайн-шопінг з доставкою замовлень у точки видачі системи, перейде на сторінку з інформацією про його замовлення (див. рис. 4.4.5) та функціоналом управління ними: трекінг стану опрацювання, функції отримання замовлення (див. рис. 4.4.6). 
     Дизайн сторінки розроблено так, щоб користувач звертав увагу на замовлення, які вже можна отримати з точки видачі  їх переміщено вгору сторінки та підсвічено акцентним бузковим кольором.

Рисунок 4.4.5  Сторінка управління замовленнями користувача


Рисунок 4.4.6  Спливаюче вікно з інформацією про замовлення 
з кнопкою «Отримати»

     Зі сторінки управління замовленнями користувач може перейти до форми розміщення нового замовлення, за допомогою якої, обравши зі списків, опції яких відфільтровуються залежно від попередніх виборів, магазин, категорію товару, товар, точку видачі, може замовити певні товари у вказаній кількості (рис. 4.4.7). Дані з форми валідуються і при некоректному введенні користувач отримує спливаючі повідомлення з підказаками.
     

Рисунок 4.4.7  Форма розміщення замовлення в системі

     Також з головної сторінки користувач може перейти до сторінки зі спеціальними пропозиціями до замовлення, перелік яких формується на основі попереднього досвіду користувача в системі (див. рис. 4.4.8).

Рисунок 4.4.8  Сторінка персоналізованих рекомендацій 
до подальших замовлень


Рисунок 4.4.9  Сторінка перегляду менеджером магазину замовлень, 
що потребують доставки до точок видачі
     Працівник компанії, що є підписницею системи та використовує точки видачі для доставки своїх товарів, після авторизації отримує доступ до управління усіма замовленнями в межах магазину, в якому працює (див рис. 4.4.9). Замовлення, що потребують якнайшвидшої доставки, відсортовуються та закріплюються вгорі сторінки.




ВИСНОВКИ

     У результаті виконання курсового проєкту з дисципліни було покращено навички зі створення складних програмних систем у процесі проєктування та імплементації програмної системи з автоматизації логістики інтернет-замовлень для вирішення проблем логістики та видачі замовлень в ніші здійснення замовлень онлайн. 
     Спроєктована система є платформою, на якій зареєстровані компанії розміщують товар для продажу, а їхні клієнти – здійснюють онлайн-покупки із подальшою доставкою в «розумні» точки видачі.  
     Розроблена система, відповідно до початкових вимог, складається з серверного застосунку, веб-клієнта, ІоТ та мобільного застосунку з використанням основних принципів проєктування архітектури програмного забезпечення.
     Для досягнення мети попередньо було також детально вивчено можливі варіанти архітектур програмного забезпечення, патерни проєктування [1], принципи «чистого» коду [2]; виконано аналіз предметної області, галузі застосування та впровадження програмного рішення; проєктування системи та бази даних. Програмну реалізацію задуму було виконано з дотриманням принципів «чистого» коду [2, 3] та «чистої» архітектури [3]. Результати проєктування та розробки викладено у пояснювальній записці до курсового проєкту.
     Для демонстрації роботи програмної системи було проведено функціональне тестування [7] основних заявлених сценаріїв її використання. 
	Програмний код системи розміщено в публічному репозиторії в системі контролю версій за рекомендованим посиланням [8].


ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ
     
     1. Прийоми об’єктно-орієнтованого проектування. Патерни проектування / Е. Гамма та ін. 368 с.
     2. Мартін Р. Чистий код. Створення і рефакторинг за допомогою Agile : 2-ге вид. Харків : Фабула, 2019. 448 с.
     3. Мартін Р. Чиста архітектура. Харків : Фабула, 2019. 368 с. 
     4. Що таке маркетплейси і яка їхня роль в електронній комерції. URL: https://foks.biz/chto-takoe-marketpleysy-i-kakova-ih-rol-v-elektronnoy-kommercii (дата звернення: 30.05.2024).
     5. Андрессон Е, Грінспун Ф, Грумет А. Проектування інтернет додатків. Массачусетс : MIT Press, 2006. 401 c.
     6. Вимоги до цільового рівня API для додатків Google Play. URL: https://support.google.com/googleplay/android-developer/answer/11926878?hl=uk (дата звернення: 30.05.2024).
     7. Демо функціонального тестування Програмної системи для автоматизації логістики інтернет-шопінгу. URL: https://youtu.be/lFD-gAYkmnU?si=oBVfQ93qXNy5CQyZ (дата звернення: 30.05.2024).
     8. Програмний код розробленої системи. URL: https://github.com/NureBerestPolina/apzkr-pzpi-21-3-berest-polina (дата звернення: 03.06.2024).
     


     ДОДАТОК А
     UML-діаграма прецедентів
     

     Рисунок А.1 – UML діаграма прецедентів для розробленої
     системи «En Route»


     ДОДАТОК Б
     UML-діаграма станів
     
      
     Рисунок Б.1 – UML діаграма станів процесу встановлення розумної точки видачі інтернет-замовлень


     ДОДАТОК В
     ER-діаграма
     

     Рисунок В.1 – ER-діаграма для створення бази даних системи


     ДОДАТОК Г
     UML-діаграма розгортання серверного застосунку
     

Рисунок Г.1 – UML-діаграма розгортання серверного застосунку із зазначенням, що зазначено, що сервер повинен містити всі бібліотеки серверної частини та 2 файли конфігурації.


     ДОДАТОК Д
     ApplicationDbContext.cs
     
      01 using EnRoute.Domain.Models;
      02 using Microsoft.AspNetCore.Identity;
      03 using Microsoft.AspNetCore.Identity.EntityFrameworkCore;
      04 using Microsoft.EntityFrameworkCore;
      05 using System.Reflection.Emit;
      06 
      07 namespace EnRoute.Domain
      08 {
      09     public class ApplicationDbContext : IdentityDbContext<User, IdentityRole<Guid>, Guid>
      10    {
      11         public DbSet<Category> Categories { get; set; }
      12         public DbSet<Producer> Producers { get; set; }
      13         public DbSet<Good> Goods { get; set; }
      14         public DbSet<Organization> Organizations { get; 
      set; }
      15         public DbSet<IssuedToken> IssuedTokens { get; set; }
      16         public DbSet<PickupCounter> PickupCounters { get; set; }
      17         public DbSet<Cell> Cells { get; set; }
      18         public DbSet<CounterInstallationRequest> CounterInstallationRequests { get; set; }
      19         public DbSet<CounterDeinstallationRequest> CounterDeinstallationRequests { get; set; }
      20         public DbSet<TechInspectionRequest> TechInspectionRequests { get; set; }
      21         public DbSet<Order> Orders { get; set; }
      22         public DbSet<OrderItem> OrderItems { get; set; }
      23 
      24         public ApplicationDbContext(DbContextOptions <ApplicationDbContext> options) : base(options)
      25         {
      26         }
      27 
      28         protected override void OnModelCreating(ModelBuilder builder)
      29         {
      30             base.OnModelCreating(builder);
      31 
      32             builder.Entity<User>()
      33                    .HasIndex(c => c.Email).IsUnique();
      34 
      35             builder.Entity<Order>()
      36                    .HasOne(o => o.Customer).WithMany()
      37                    .HasForeignKey(o => o.CustomerId)
      38                    .OnDelete(DeleteBehavior.NoAction);
      39 
      40             builder.Entity<OrderItem>()
      41                    .HasOne(o => o.Order).WithMany(o => o.Items)
      42                    .HasForeignKey(o => o.OrderId)
      43                    .OnDelete(DeleteBehavior.NoAction);
      44 
      45             builder.Entity<Cell>()
      46                    .HasOne(c => c.Counter).WithMany(p => p.Cells)
      47                    .HasForeignKey(c => c.CounterId)
      48                    .OnDelete(DeleteBehavior.Cascade);
      49         }
      50     }
      51 }


     ДОДАТОК E
     AppRoutingModule.ts
     
      001 import { NgModule } from '@angular/core';
      002 import { RouterModule, Routes } from '@angular/router';
      003 import { BlockedComponent } from './components/common/ blocked/blocked.component';
      004 import { NotFoundComponent } from './components/common/not-found/not-found.component';
      005 import { HomeComponent } from './components/public/home/ home.component';
      006 import { LoginComponent } from './components/public/login/ login.component';
      007 import { RegisterComponent } from './components/public/ register/register.component';
      008 import { AssortmentComponent } from './components/ organizations/assortment/assortment.component';
      009 import { AddGoodComponent } from './components/ organizations/add-good/add-good.component';
      010 import { EditGoodComponent } from './components/organizations/edit-good/edit-good.component';
      011 import { AddProducerComponent } from './components /organizations/add-producer/add-producer.component';
      012 import { BackupsManagementComponent } from './components /sysadmin/backups-management/backups-management.component';
      013 import { CountersListComponent } from './components/ organizations/counters-management/counters-list/counters-list.component';
      014 import { MakeInstallCounterRequestComponent } from './components/organizations/counters-management/make-install-counter-request/make-install-counter-request.component';
      015 import { ManageCounterInstallRequestsComponent } from './components/admin/manage-counter-install-requests/manage-counter-install-requests.component';
      016 import { AddCounterUriComponent } from './components/ admin/add-counter-uri/add-counter-uri.component';
      017 import { ManageOrganizationsComponent } from './components/ admin/manage-organizations/manage-organizations.component';
      018 import { SystemStatisticsComponent } from './components /admin/system-statistics/system-statistics.component';
      019 import { StatisticsComponent } from './components/ organizations/statistics/statistics.component';
      020 import { ManageTechinspectionRequestsComponent } from './components/admin/manage-techinspection-requests/manage-techinspection-requests.component';
      021 
      022 const routes: Routes = [
      023   {
      024     path: '',
      025     component: HomeComponent,
      026   },
      027   {
      028     path: 'notFound',
      029     component: NotFoundComponent,
      030   },
      031   {
      032     path: 'blocked',
      033     component: BlockedComponent,
      034   },
      035   {
      036     path: 'login',
      037     component: LoginComponent,
      038   },
      039   {
      040     path: 'register',
      041     component: RegisterComponent,
      042   },
      043   {
      044     path: 'shopManagement/:organizationId/assortment',
      045     component: AssortmentComponent,
      046   },
      047   {
      048     path: 'shopManagement/:organizationId/counters',
      049     component: CountersListComponent,
      050   },
      051   {
      052     path: 'shopManagement/:organizationId/make-counter-installation-request',
      053     component: MakeInstallCounterRequestComponent,
      054   },
      055   {
      056     path: 'shopManagement/:organizationId/add-good',
      057     component: AddGoodComponent,
      058   },
      059   {
      060     path: 'shopManagement/:organizationId/edit-good/:goodId',
      061     component: EditGoodComponent,
      062   },
      063   {
      064     path: 'shopManagement/:organizationId/counters/statistics',
      065     component: StatisticsComponent,
      066   },
      067   {
      068     path: 'shopManagement/:organizationId/add-producer',
      069     component: AddProducerComponent,
      070   },
      071   {
      072     path: 'admin/system-administration',
      073     component: BackupsManagementComponent,
      074   },
      075   {
      076     path: 'admin/counters-installation-requests',
      077     component: ManageCounterInstallRequestsComponent,
      078   },
      079   {
      080     path: 'admin/counter-installation-requests/:requestId/add-uri',
      081     component: AddCounterUriComponent,
      082   },
      083   {
      084     path: 'admin/billing/statistics',
      085    component: SystemStatisticsComponent,
      086   },
      087   {
      088     path: 'admin/organizations-management',
      089     component: ManageOrganizationsComponent,
      090   },
      091   {
      092     path: 'admin/techinspection-requests-management',
      093     component: ManageTechinspectionRequestsComponent,
      094   }
      095 ];
      096 
      097 @NgModule({
      098   imports: [RouterModule.forRoot(routes, { anchorScrolling: 'enabled' })],
      099   exports: [RouterModule],
      100 })
      101 export class AppRoutingModule { }


ДОДАТОК Ж
AuthInterceptor.java
      
      01 /**
      02  * Interceptor for adding authentication headers to HTTP requests.
      03  * This interceptor is responsible for adding the Authorization header with a Bearer token
      04  * obtained from the TokenStorageService to outgoing requests. It also handles token refreshing
      05  * if a 401 (Unauthorized) response is received.
      06  */
      07 package com.example.enroute.interceptors;
      08 
      09 import com.example.enroute.services.AuthService;
      10 import com.example.enroute.services.TokenStorageService;
      11 
      12 import java.io.IOException;
      13 
      14 import okhttp3.Interceptor;
      15 import okhttp3.Request;
      16 import okhttp3.Response;
      17 
      18 public class AuthInterceptor implements Interceptor {
      19     private TokenStorageService tokenService;
      20     private AuthService authService;
      21 
      22     /**
      23      * Constructs an AuthInterceptor with the specified TokenStorageService and AuthService.
      24      *
      25      * @param tokenService The TokenStorageService used to retrieve and store authentication tokens.
      26      * @param authService  The AuthService used to perform token refreshing and logout actions.
      27      */
      28     public AuthInterceptor(TokenStorageService tokenService, AuthService authService) {
      29         this.tokenService = tokenService;
      30         this.authService = authService;
      31     }
      32 
      33     /**
      34      * Intercepts the HTTP request to add the Authorization header with the Bearer token.
      35      * If a 401 response is received, it attempts to refresh the token and retries the request.
      36      *
      37      * @param chain The interceptor chain.
      38      * @return The response to the intercepted request.
      39      * @throws IOException If an I/O error occurs during the interception.
      40      */
      41     @Override
      42     public Response intercept(Chain chain) throws 
      IOException {
      43         Request originalRequest = chain.request();
      44         Request.Builder requestBuilder = originalRequest.newBuilder();
      45 
      46         String token = tokenService.getToken();
      47         if (token != null) {
      48             requestBuilder.addHeader("Authorization", "Bearer " + token);
      49         }
      50 
      51         Request authRequest = requestBuilder.build();
      52         Response response = chain.proceed(authRequest);
      53 
      54         if (response.code() == 401) {
      55             String refreshToken = tokenService.getRefreshToken();
      56             if (refreshToken != null) {
      57                 synchronized (this) {
      58                     String newToken = authService.refreshToken(token, refreshToken).getRefreshToken();
      59                     if (newToken != null) {
      60                         requestBuilder.header("Authorization", "Bearer " + newToken);
      61                         authRequest = requestBuilder.build();
      62                         return chain.proceed(authRequest);
      63                     } else {
      64                         authService.logout();
      65                     }
      66                 }
      67             } else {
      68                 authService.logout();
      69             }
      70         }
      71 
      72         return response;
      73     }
      74 }
      


     ДОДАТОК И
     AuthService.cs
     
      001 using EnRoute.Common.Configuration;
      002 using EnRoute.Common.Constants;
      003 using EnRoute.Domain;
      004 using EnRoute.Domain.Models;
      005 using EnRoute.Infrastructure.Commands;
      006 using EnRoute.Infrastructure.Constants;
      007 using EnRoute.Infrastructure.Extentions;
      008 using EnRoute.Infrastructure.Services.Interfaces;
      009 using EnRoute.Infrastructure.Strategies;
      010 using Microsoft.AspNetCore.Identity;
      011 using Microsoft.EntityFrameworkCore;
      012 using System.Security.Authentication;
      013 using System.Security.Claims;
      014 
      015 namespace EnRoute.Infrastructure.Services
      016 {
      017     /// <summary>
      018     /// Service handling authentication operations.
      019     /// </summary>
      020     public class AuthService : IAuthService
      021     {
      022         private readonly ApplicationDbContext dbContext;
      023         private readonly UserManager<User> userManager;
      024         private readonly JwtSettings jwtSettings;
      025         private readonly IJwtTokenService jwtTokenService;
      026    	 private readonly IRoleStrategyFactory roleStrategyFactory;
      027
      028         public AuthService(
      029         ApplicationDbContext dbContext, 
      030         UserManager<User> userManager, 
      031         JwtSettings jwtSettings, 
      032         IJwtTokenService jwtTokenService, 
      033         IRoleStrategyFactory roleStrategyFactory
      034         )
      035         {
      036             this.dbContext = dbContext;
      037             this.userManager = userManager;
      038             this.jwtSettings = jwtSettings;
      039             this.jwtTokenService = jwtTokenService;
      040             this.roleStrategyFactory = roleStrategyFactory;
      041         }
      042 
      043         /// <summary>
      044         /// Generates a token for the given user.
      045         /// </summary>
      046         /// <param name="user">User entity for which the token is generated.</param>
      047         /// <returns>A tuple containing the generated token and its refresh token.</returns>
      048         public async Task<(string Token, string RefreshToken)> GenerateTokenForUserAsync(User user)
      049         {
      050             var authClaims = new List<Claim>
      051         {
      052             new(JwtClaims.Sub, user.Id.ToString()),
      053             new(JwtClaims.Email, user.Email!),
      054             new(JwtClaims.RegisterDate, user.RegisterDate.ToString("O")),
      055             new(JwtClaims.Name, user.Name)
      056         };
      057 
      058             var userClaims = await userManager.GetClaimsAsync(user);
      059             var roleClaims = userClaims.Where(c => c.Type == ClaimTypes.Role).Select(c => c.Value).ToArray();
      060 
      061             authClaims.Add(new Claim(JwtClaims.Roles, string.Join<string>(",", roleClaims)));
      062 
      063             var token = jwtTokenService .CreateToken(authClaims);
      064             var refreshToken = jwtTokenService .GenerateRefreshToken();
      065 
      066 
      067             var serializedToken = token.SerializeToString();
      068 
      069             var issuedToken = new IssuedToken
      070             {
      071                 User = user,
      072                 Token = serializedToken,
      073                 RefreshToken = refreshToken,
      074                 RefreshTokenExpirationTime = DateTime.UtcNow.AddDays(jwtSettings.RefreshTokenValidityInDays)
      075             };
      076 
      077             dbContext.IssuedTokens.Add(issuedToken);
      078             await dbContext.SaveChangesAsync();
      079 
      080             return (serializedToken, refreshToken);
      081         }
      082 
      083         /// <summary>
      084         /// Registers a new user with the provided registration information.
      085         /// </summary>
      086         /// <param name="command">Registration command containing user information.</param>
      087         /// <returns>The newly registered user.</returns>
      088         public async Task<User> RegisterUserAsync(RegisterCommand command)
      089         {
      090             var user = new User()
      091             {
      092                 Email = command.Email,
      093                 UserName = command.Email,
      094                 Name = command.Name
      095             };
      096 
      097             var result = await userManager.CreateAsync(user, command.Password);
      098 
      099             if (!result.Succeeded)
      100             {
      101                 throw new Exception($"Unexpected error during user registration: {string.Join(", ", result.Errors)}.");
      102             }
      103 
      104             var createdUser = await userManager.FindByEmailAsync(user.Email);
      105             if (createdUser is null)
      106             {
      107                 throw new Exception("Registered user not found.");
      108             }
      109 
      110             try
      111             {
      112                 var claimAssignmentResult = await userManager.AddClaimAsync(createdUser, new Claim(ClaimTypes.Role, command.Role.ToLower()));
      113 
      114                 if (!claimAssignmentResult.Succeeded)
      115                 {
      116                     throw new ArgumentException($"Unexpected error during role claim assignment: {string.Join(", ", claimAssignmentResult.Errors)}.", nameof(command.Role));
      117                 }
      118 
      119                 var strategy = roleStrategyFactory.CreateStrategy(command.Role.ToLower());
      120                 await strategy.ExecuteRoleSpecificActionAsync(createdUser, command, dbContext);
      121                 await dbContext.SaveChangesAsync();
      122             }
      123             catch (Exception)
      124             {
      125                 await userManager.DeleteAsync(createdUser);
      126                 throw;
      127             }
      128 
      129             return createdUser;
      130         }
      131 
      132         /// <summary>
      133         /// Refreshes the provided JWT token using the refresh token.
      134         /// </summary>
      135         /// <param name="token">Expired JWT token.</param>
      136         /// <param name="refreshToken">Refresh token.</param>
      137         /// <returns>A tuple containing the new token and refresh token.</returns>
      138         public async Task<(string Token, string RefreshToken)> RefreshToken(string token, string refreshToken)
      139         {
      140             var principal = this.jwtTokenService.GetPrincipalFromExpiredToken(token);
      141             if (principal == null)
      142             {
      143                 throw new AuthenticationException("Invalid access token or refresh token");
      144             }
      145 
      146             var userId = Guid.Parse(principal.FindFirst(c => c.Type == ClaimTypes.NameIdentifier)!.Value);
      147 
      148             var user = await dbContext.Users
      149                 .Include(c => c.IssuedTokens)
      150                 .Where(u => u.Id == userId &&
      151                             u.IssuedTokens.Any(t =>
      152                                 t.RefreshToken == refreshToken && DateTime.UtcNow <= t.RefreshTokenExpirationTime))
      153                 .FirstOrDefaultAsync();
      154 
      155             if (user == null)
      156             {
      157                 throw new AuthenticationException("Invalid access token or refresh token");
      158             }
      159             var currentToken = user.IssuedTokens.First(c => c.RefreshToken == refreshToken);
      160             dbContext.IssuedTokens.Remove(currentToken);
      161             return await GenerateTokenForUserAsync(user);
      162         }
      163     }
      164 }
     ДОДАТОК К
     ODataControllerBase.cs
     
      01 using EnRoute.Domain;
      02 using EnRoute.Domain.Utils;
      03 using EnRoute.Domain.Models.Interfaces;
      04 using Microsoft.AspNetCore.Authorization;
      05 using Microsoft.AspNetCore.Mvc;
      06 using Microsoft.AspNetCore.OData.Formatter;
      07 using Microsoft.AspNetCore.OData.Query;
      08 using Microsoft.AspNetCore.OData.Routing.Controllers;
      09 using Microsoft.EntityFrameworkCore;
      10 
      11 namespace EnRoute.API.Controllers
      12 {
      13     [Authorize]
      14     public class ODataControllerBase<T> : ODataController where T : class, IODataEntity
      15     {
      16         protected readonly ApplicationDbContext AppDbContext;
      17         protected readonly DbSet<T> CurrentDbSet;
      18 
      19         public ODataControllerBase(ApplicationDbContext appDbContext)
      20         {
      21             AppDbContext = appDbContext;
      22             CurrentDbSet = appDbContext.Set<T>();
      23         }
      24 
      25         [EnableQuery]
      26         public virtual IActionResult Get()
      27         {
      28             return Ok(CurrentDbSet);
      29         }
      30 
      31         [EnableQuery]
      32         public virtual async Task<IActionResult> Get(Guid key)
      33         {
      34             var item = await CurrentDbSet.FirstOrDefaultAsync(e => e.Id == key);
      35             return item is null ? NotFound() : (IActionResult)Ok(item);
      36         }
      37 
      38         [EnableQuery]
      39         public virtual async Task<IActionResult> Post([FromBody] T entity)
      40         {
      41             var allErrors = ModelState.Values.SelectMany(v => v.Errors).ToArray();
      42             if (allErrors.Any()) 
      43                 return BadRequest(string.Join(", ", allErrors.Select(err => err.Exception)));
      44 
      45             CurrentDbSet.Add(entity);
      46             await AppDbContext.SaveChangesAsync();
      47             return Created(entity);
      48         }
      49 
      50         public virtual async Task<IActionResult> Put([FromODataUri] Guid key, [FromBody] T entity)
      51         {
      52             var dbEntity = await CurrentDbSet.FindAsync(key);
      53             if (dbEntity is null) 
      54                 return NotFound();
      55 
      56             entity.Id = key;
      57             AppDbContext.DetachLocal(entity, key);
      58             CurrentDbSet.Update(entity);
      59             await AppDbContext.SaveChangesAsync();
      60             return Updated(entity);
      61         }
      62 
      63         public virtual async Task<IActionResult> Delete([FromRoute] Guid key)
      64         {
      65             var entityFromStorage = await CurrentDbSet.FirstOrDefaultAsync(l => l.Id == key);
      66             if (entityFromStorage is null) 
      67                 return NotFound();
      68                 
      69             CurrentDbSet.Remove(entityFromStorage);
      70             await AppDbContext.SaveChangesAsync();
      71             return NoContent();
      72         }
      73     }
      74 }


     ДОДАТОК Л
     Специфікація REST API
     
     Таблиця Л.1 – Специфікація REST API
ПосиланняМетодПризначення/api/Auth/loginPOSTВхід до системи (авторизація)/api/Auth/registerPOSTРеєстрація користувача/api/Auth/registerCompanyPOSTРеєстрація користувача як менеджера компанії/api/Auth/refresh-tokenPOSTОтримання нового токена на основі токена для оновлення/api/Backup/createPOSTСтворення бекапу/api/Backup/allGETОтримання всіх бекапів/odata/CategoriesGETОтримання всіх категорій/odata/Categories/{key}GETОтримання конкретної категорії/odata/CategoriesPOSTСтворення категорії товарів/odata/Categories/{key}PUTРедагування категорії/odata/Categories/{key}DELETEВидалення категорії/odata
/CounterDeinstallationRequestsGETОтримання всіх заявок про деінсталяцію точок видачі/odata
/CounterDeinstallationRequests /{key}GETОтримання всіх заявок про деінсталяцію точок видачі від певної компанії/odata
/CounterDeinstallationRequests /{key}GETОтримання конкретної заявки про деінсталяцію точки видачі     
     
     
     Продовження табл. Л.1
/odata
/CounterDeinstallationRequestsPOSTСтворення заявки на деінсталяцію точки видачі/odata
/CounterDeinstallationRequests /{key}PUTРедагування заявки на деінсталяцію точки видачі/odata
/CounterDeinstallationRequests /{key}DELETEВидалення заявки на деінсталяцію холодильника/odata/CounterInstallationRequestsGETОтримання всіх заявок про встановлення точок видачі/odata
/CounterІnstallationRequests 
/{key}GETОтримання всіх заявок про встановлення точок видачі від певної компанії/odata
/CounterІnstallationRequests 
/{key}GETОтримання конкретної заявки про встановлення точки видачі/odata
/CounterІnstallationRequestsPOSTСтворення заявки на встановлення точки видачі із указанням необхідної конфігурації /odata
/CounterІnstallationRequests
/{key}PUTРедагування заявки на встановлення точки видачі/odata
/CounterІnstallationRequests 
/{key}DELETEВидалення заявки на встановлення точки видачі     
     

     Продовження табл. Л.1
/api/CounterInstallationRequests
/{key}/fulfillPUTПідтвердження виконання заявки на встановлення точки видачі, зміна стану заявки, створення об’єкту точки видачі та необхідної кількості комірок заданої в заявці конфігурації/api/Delivery/get-delivery-list/{key}GETОтримання інформації для здійснення доставки замовлень до точок видачі певної компанії/ api/Delivery
/get-counter-delivery-list/{key}GETОтримання інформації для здійснення доставки замовлень до конкретної точки видачі/odata/GoodsGETОтримання всіх товарів/odata/Goods/{key}GETОтримання всіх товарів з асортименту певної компанії/odata/Goods/{key}GETОтримання конкретного товару/odata/Goods/{key}GETОтримання товарів певної категорії/odata/GoodsPOSTСтворення товару/odata/Goods/{key}PUTРедагування товару/odata/Goods/{key}DELETEВидалення товару/api/OrderItems
/RecommendationsGETОтримання персональних рекомендацій щодо товарів для замовлення
     Продовження табл. Л.1
/odata/OrderItemsGETОтримання всіх позицій усіх актуальних замовлень/odata/OrderItems/{key}GETОтримання всіх позицій з конкретного замовлення/odata/OrderItems/{key}GETОтримання всіх позицій із замовлень на товари певної організації/odata/OrderItemsPOSTСтворення нової позиції в замовленні/odata/OrderItems/{key}PUTРедагування позиції замовлення/odata/OrderItems/{key}DELETEВидалення позиції з замовлення/odata/OrdersGETОтримання всіх замовлень/odata/Orders/{key}GETОтримання всіх замовлень користувача/odata/Orders/{key}GETОтримання конкретного замовлення/odata/OrdersPOSTСтворення замовлення/odata/Orders/{key}PUTОтримання замовлення – взаємодія з холодильником/odata/Orders/{key}DELETEВидалення замовлення/odata/OrganizationsGETОтримання всіх організацій/odata/Organizations/{key}GETОтримання конкретної організації/odata/OrganizationsPOSTСтворення організації/odata/Organizations/{key}PUTРедагування організації/odata/Organizations/{key}DELETEБлокування організації/odata/PickupCountersGETОтримання всіх точок видачі/odata/PickupCounters/{key}GETОтримання конкретної точки видачі/odata/PickupCounters/{key}GETОтримання всіх точок видачі, якими користується певна організація     Продовження табл. Л.1
/odata/PickupCountersPOSTСтворення точки видачі в системі після підтвердження інсталяції адміністратором/odata/PickupCounters/{key}PUTРедагування налаштувань точки видачі/odata/PickupCounters/{key}DELETEВидалення інформації про точку видачі після підтвердження адміністратором деінсталяції точки видачі/odata/ProducersGETОтримання всіх виробників товарів, доданих до системи/odata/Producers/{key}GETОтримання конкретного виробника/odata/ProducersPOSTДодавання інформації про виробника/odata/Producers/{key}PUTРедагування інформації про виробника/odata/Producers/{key}DELETEВидалення інформації про виробника із каскадним видаленням його товарів /api/Statistics/AdminGETОтримання статистики щодо активності використання компаніями системи та зареєстрованих точок видачі/api/Statistics/Organization
/{key}GETОтримання статистики по використанню точок видачі, кількості та видів замовлень у різних точках встановлення      
     Продовження табл. Л.1
/odata
/TechInspectionRequestsGETОтримання всіх запитів на технічну підтримку точок видачі/odata
/TechInspectionRequests /{key}GETОтримання конкретного запиту на технічну підтримку/odata
/TechInspectionRequestsPOSTСтворення запиту на технічну підтримку, отриманого від точки видачі/odata
/TechInspectionRequests
/{key}PUTРедагування запиту на технічну підтримку/odata
/TechInspectionRequests
/{key}DELETEВидалення запиту на технічну підтримку по її проведенню, скидання значень в комірці, яка «ініціювала» запит     


     ДОДАТОК М
     Результат перевірки на відсоток плагіату
2


